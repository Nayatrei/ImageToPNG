/* Enhanced converter.js with 3D printing optimizations */
/* global ImageTracer, chrome */

document.addEventListener('DOMContentLoaded', () => {
  // --- DOM elements ---
  const elements = {
    sourceImage: document.getElementById('source-image'),
    statusText: document.getElementById('status-text'),
    generateBtn: document.getElementById('generate-btn'),
    
    // Quantization controls
    paletteSizeInput: document.getElementById('palette-size'),
    deterministicSeedInput: document.getElementById('deterministic-seed'),
    pickBgBtn: document.getElementById('pick-bg-btn'),
    removeBgCheckbox: document.getElementById('remove-bg'),
    paletteContainer: document.getElementById('palette-container'),
    paletteRow: document.getElementById('palette-row'),
    lockPaletteCheckbox: document.getElementById('lock-palette'),

    // Tracing controls
    minFeatureSizeSlider: document.getElementById('min-feature-size'),
    minFeatureSizeValue: document.getElementById('min-feature-size-value'),
    curveToleranceSlider: document.getElementById('curve-tolerance'),
    curveToleranceValue: document.getElementById('curve-tolerance-value'),
    cornerPreservationSlider: document.getElementById('corner-preservation'),
    cornerPreservationValue: document.getElementById('corner-preservation-value'),

    // Preview and UI
    quantizedPreview: document.getElementById('quantized-preview'),
    svgPreview: document.getElementById('svg-preview'),
    svgPreviewFiltered: document.getElementById('svg-preview-filtered'),
    qualityIndicator: document.getElementById('quality-indicator'),
    showQuantizedBtn: document.getElementById('show-quantized-btn'),
    showVectorBtn: document.getElementById('show-vector-btn'),
    
    // File handling
    importBtn: document.getElementById('import-btn'),
    fileInput: document.getElementById('file-input'),
    urlInput: document.getElementById('url-input'),
    loadUrlBtn: document.getElementById('load-url-btn'),
    
    // Download buttons
    downloadTinkercadBtn: document.getElementById('download-tinkercad-btn'),
    downloadSilhouetteBtn: document.getElementById('download-silhouette-btn'),
    colorButtonsRow: document.getElementById('color-buttons-row'),
    
    // Resolution displays
    originalResolution: document.getElementById('original-resolution'),
    scaledResolution: document.getElementById('scaled-resolution')
  };

  // --- State ---
  let tracedata = null;
  let quantizedData = null;
  let originalImageUrl = null;
  let bgEstimate = null;
  let lastOptions = null;
  let autoGeneratedOnce = false;
  let silhouetteTracedata = null;
  let silhouetteUrl = null;

  // --- UI Setup ---
  const setupSlider = (slider, valueDisplay, decimals = 0, callback = null) => {
    if (!slider || !valueDisplay) return;
    
    const updateValue = () => {
      const value = parseFloat(slider.value);
      valueDisplay.textContent = value.toFixed(decimals);
      if (callback) callback(value);
    };
    
    slider.addEventListener('input', updateValue);
    updateValue(); // Initialize
  };

  setupSlider(elements.minFeatureSizeSlider, elements.minFeatureSizeValue, 0);
  setupSlider(elements.curveToleranceSlider, elements.curveToleranceValue, 1);
  setupSlider(elements.cornerPreservationSlider, elements.cornerPreservationValue, 1);

  // --- Event Listeners ---

  elements.generateBtn.addEventListener('click', async () => {
    if (!elements.sourceImage.src) {
      alert('Please load an image before generating a preview.');
      return;
    }

    elements.statusText.textContent = '⚡ Quantizing colors...';
    elements.generateBtn.disabled = true;
    disableDownloadButtons();
    
    if (elements.qualityIndicator) {
      elements.qualityIndicator.textContent = '';
      elements.qualityIndicator.className = 'quality-indicator';
    }

    setTimeout(async () => {
      try {
        await runFullProcess();
      } catch (error) {
        console.error('Generation error:', error);
        elements.statusText.textContent = '❌ Error during conversion. Try adjusting settings.';
      } finally {
        elements.generateBtn.disabled = false;
      }
    }, 50);
  });

  elements.showQuantizedBtn.addEventListener('click', () => {
    elements.quantizedPreview.style.display = 'block';
    elements.svgPreview.style.display = 'none';
    elements.showQuantizedBtn.classList.add('active');
    elements.showVectorBtn.classList.remove('active');
  });

  elements.showVectorBtn.addEventListener('click', () => {
    elements.quantizedPreview.style.display = 'none';
    elements.svgPreview.style.display = 'block';
    elements.showQuantizedBtn.classList.remove('active');
    elements.showVectorBtn.classList.add('active');
  });

  // --- Main Process ---

  async function runFullProcess() {
    // 1. Quantization
    await quantizeImage();
    displayQuantizedPreview();
    displayPalette();

    // 2. Tracing
    await traceImage();
    renderPreviews();
    
    const quality = assess3DPrintQuality(tracedata);
    updateQualityDisplay(quality);
    
    elements.statusText.textContent = `✅ Preview generated! ${quality.colorCount} layers, ${quality.pathCount} paths`;
    enableDownloadButtons();
    renderColorButtons();
  }

  async function quantizeImage() {
    return new Promise((resolve, reject) => {
      const width = elements.sourceImage.naturalWidth;
      const height = elements.sourceImage.naturalHeight;
      
      if (!width || !height) {
        return reject(new Error('Invalid image dimensions'));
      }

      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(elements.sourceImage, 0, 0, width, height);
      const imageData = ctx.getImageData(0, 0, width, height);

      if (elements.removeBgCheckbox.checked) {
        bgEstimate = estimateEdgeBackground(imageData);
        knockOutBackground(imageData, bgEstimate, 30);
      }

      const options = {
        numberofcolors: parseInt(elements.paletteSizeInput.value),
        colorsampling: 2, // Deterministic sampling
      };

      quantizedData = ImageTracer.colorquantization(imageData, options);
      resolve();
    });
  }

  function displayQuantizedPreview() {
    if (!quantizedData) return;

    const canvas = elements.quantizedPreview;
    const ctx = canvas.getContext('2d');
    const width = quantizedData.array[0].length - 2;
    const height = quantizedData.array.length - 2;
    canvas.width = width;
    canvas.height = height;

    const imageData = ctx.createImageData(width, height);
    for (let j = 0; j < height; j++) {
      for (let i = 0; i < width; i++) {
        const colorIndex = quantizedData.array[j + 1][i + 1];
        const color = quantizedData.palette[colorIndex];
        const pixelIndex = (j * width + i) * 4;
        imageData.data[pixelIndex] = color.r;
        imageData.data[pixelIndex + 1] = color.g;
        imageData.data[pixelIndex + 2] = color.b;
        imageData.data[pixelIndex + 3] = color.a;
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }

  async function traceImage() {
    if (!quantizedData) {
      alert('Please quantize the image first.');
      return;
    }

    elements.statusText.textContent = '🔄 Tracing paths...';

    const options = buildOptimizedOptions();
    lastOptions = options;

    // Use quantized data for tracing
    tracedata = ImageTracer.imagedataToTracedata({
      width: quantizedData.array[0].length - 2,
      height: quantizedData.array.length - 2,
      data: getImageDataFromQuantized(quantizedData).data
    }, options);

    if (!tracedata || !tracedata.layers || tracedata.layers.length === 0) {
      elements.statusText.textContent = '❌ No paths/colors found. Try different tracing settings.';
      alert('SVG generation failed: No paths/colors found.');
      return;
    }

    elements.statusText.textContent = '🛠️ Optimizing for 3D printing...';
    tracedata = forceSolidShapes(tracedata);
    tracedata = mergeSimilarColors(tracedata, 20);
  }
  
  function getImageDataFromQuantized(quantizedData) {
    const width = quantizedData.array[0].length - 2;
    const height = quantizedData.array.length - 2;
    const imageData = new ImageData(width, height);
    for (let j = 0; j < height; j++) {
        for (let i = 0; i < width; i++) {
            const colorIndex = quantizedData.array[j + 1][i + 1];
            const color = quantizedData.palette[colorIndex];
            const pixelIndex = (j * width + i) * 4;
            imageData.data[pixelIndex] = color.r;
            imageData.data[pixelIndex + 1] = color.g;
            imageData.data[pixelIndex + 2] = color.b;
            imageData.data[pixelIndex + 3] = color.a;
        }
    }
    return imageData;
  }

  function buildOptimizedOptions() {
    const options = Object.assign({}, ImageTracer.optionpresets.default, {
        numberofcolors: quantizedData.palette.length,
        pal: quantizedData.palette,
        viewbox: true,
        strokewidth: 0,
        roundcoords: 2,
        pathomit: parseInt(elements.minFeatureSizeSlider.value),
        ltres: parseFloat(elements.curveToleranceSlider.value),
        qtres: parseFloat(elements.curveToleranceSlider.value),
    });
    return options;
  }

  // --- Helper Functions (many are the same as before) ---

  function assess3DPrintQuality(tracedata) {
    if (!tracedata) return { level: 'unknown', message: 'No data', className: '' };
    
    const totalPaths = tracedata.layers.reduce((sum, layer) => {
      return sum + (Array.isArray(layer) ? layer.length : 0);
    }, 0);
    
    const visibleColors = countVisibleLayers(tracedata);
    
    let level, message, className;
    
    if (totalPaths <= 50) {
      level = 'excellent';
      message = `🏆 Excellent for 3D printing! ${totalPaths} paths, ${visibleColors} colors - perfect for Tinkercad`;
      className = 'quality-excellent';
    } else if (totalPaths <= 150) {
      level = 'good';
      message = `👍 Good quality! ${totalPaths} paths, ${visibleColors} colors - should work well in Tinkercad`;
      className = 'quality-good';
    } else {
      level = 'poor';
      message = `⚠️ Too complex for optimal 3D printing! ${totalPaths} paths - try increasing simplification level`;
      className = 'quality-poor';
    }
    
    return { level, message, className, pathCount: totalPaths, colorCount: visibleColors };
  }

  function updateQualityDisplay(quality) {
    if (!elements.qualityIndicator) return;
    
    elements.qualityIndicator.textContent = quality.message;
    elements.qualityIndicator.className = `quality-indicator ${quality.className}`;
  }

  function renderPreviews() {
    if (!tracedata) return;
    
    const visibleIndices = getVisiblePaletteIndices();
    const previewData = visibleIndices.length 
      ? buildTracedataSubset(tracedata, visibleIndices)
      : Object.assign({}, tracedata, { layers: [], palette: [] });

    const svgString = ImageTracer.getsvgstring(previewData, lastOptions);
    const blob = new Blob([svgString], { type: 'image/svg+xml' });
    elements.svgPreview.data = URL.createObjectURL(blob);

    const holeRemovalLevel = 1;
    silhouetteTracedata = createSolidSilhouette(tracedata, holeRemovalLevel);
    
    if (silhouetteTracedata) {
      const silhouetteSvg = ImageTracer.getsvgstring(silhouetteTracedata, lastOptions);
      const silhouetteBlob = new Blob([silhouetteSvg], { type: 'image/svg+xml' });
      silhouetteUrl = URL.createObjectURL(silhouetteBlob);
    }

    selectBackgroundLayerOnly();
    updateFilteredPreview();
  }

  function displayPalette() {
    if (!quantizedData || !elements.paletteContainer) return;
    
    elements.paletteContainer.innerHTML = '';
    
    if (quantizedData.palette.length === 0) {
      elements.paletteRow.style.display = 'none';
      return;
    }

    quantizedData.palette.forEach((color, index) => {
        const label = document.createElement('label');
        label.style.display = 'inline-block';
        label.style.margin = '4px 8px';
        label.style.cursor = 'pointer';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.index = index;
        checkbox.style.marginRight = '6px';
        
        const swatch = document.createElement('span');
        Object.assign(swatch.style, {
            display: 'inline-block',
            width: '20px',
            height: '20px',
            backgroundColor: `rgba(${color.r},${color.g},${color.b},${color.a/255})`,
            border: '2px solid #333',
            borderRadius: '3px',
            verticalAlign: 'middle',
            marginLeft: '4px'
        });
        
        const colorInfo = document.createElement('small');
        colorInfo.textContent = ` Layer ${index + 1}`;
        colorInfo.style.marginLeft = '6px';
        colorInfo.style.color = '#666';
        
        label.appendChild(checkbox);
        label.appendChild(swatch);
        label.appendChild(colorInfo);
        elements.paletteContainer.appendChild(label);
    });
    
    elements.paletteRow.style.display = 'table-row';
    
    elements.paletteContainer.addEventListener('change', (e) => {
      if (e.target.type !== 'checkbox') return;
      updateFilteredPreview();
    });
  }

  function updateFilteredPreview() {
    if (!tracedata || !elements.svgPreviewFiltered) return;
    const paletteEl = elements.paletteContainer;
    if (!paletteEl) return;

    const selectedCheckboxes = Array.from(paletteEl.querySelectorAll('input[type="checkbox"]:checked'));

    if (selectedCheckboxes.length === 0) {
        elements.svgPreviewFiltered.data = '';
        return;
    }

    const indicesToRender = selectedCheckboxes
        .map(cb => parseInt(cb.dataset.index, 10))
        .filter(idx => !isNaN(idx));

    const filteredData = buildTracedataSubset(tracedata, indicesToRender);

    if (filteredData && filteredData.layers.length > 0 && filteredData.layers.some(layer => layer.length > 0)) {
        const svgString = ImageTracer.getsvgstring(filteredData, lastOptions);
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        elements.svgPreviewFiltered.data = URL.createObjectURL(blob);
    } else {
        elements.svgPreviewFiltered.data = '';
    }
  }

  function getVisiblePaletteIndices() {
    if (!tracedata) return [];
    
    const indices = [];
    for (let i = 0; i < tracedata.palette.length; i++) {
      const color = tracedata.palette[i];
      if (layerHasPaths(tracedata.layers[i])) {
        indices.push(i);
      }
    }
    return indices;
  }

  function layerHasPaths(layer) {
    return Array.isArray(layer) && layer.length > 0;
  }

  function buildTracedataSubset(sourceTracedata, indices) {
    if (!sourceTracedata) return null;
    
    const layers = [];
    const palette = [];
    
    indices.forEach(idx => {
      if (sourceTracedata.layers[idx] && sourceTracedata.palette[idx]) {
        layers.push(JSON.parse(JSON.stringify(sourceTracedata.layers[idx])));
        palette.push(sourceTracedata.palette[idx]);
      }
    });
    
    return { ...sourceTracedata, layers, palette };
  }

  function countVisibleLayers(tracedata) {
    if (!tracedata) return 0;
    
    let count = 0;
    for (let i = 0; i < tracedata.palette.length; i++) {
      if (layerHasPaths(tracedata.layers[i])) {
        count++;
      }
    }
    return count;
  }

  function forceSolidShapes(tracedata) {
    return mergeSimilarColors(tracedata, 35);
  }

  function mergeSimilarColors(tracedata, threshold) {
    if (!tracedata || !tracedata.palette) return tracedata;
    
    const { palette, layers } = tracedata;
    const used = new Array(palette.length).fill(false);
    const groups = [];
    
    for (let i = 0; i < palette.length; i++) {
      if (used[i]) continue;
      
      const group = [i];
      used[i] = true;
      const color1 = palette[i];
      
      for (let j = i + 1; j < palette.length; j++) {
        if (used[j]) continue;
        
        const color2 = palette[j];
        const distance = Math.sqrt(
          Math.pow(color1.r - color2.r, 2) +
          Math.pow(color1.g - color2.g, 2) +
          Math.pow(color1.b - color2.b, 2)
        );
        
        if (distance <= threshold) {
          group.push(j);
          used[j] = true;
        }
      }
      groups.push(group);
    }
    
    const newPalette = [];
    const newLayers = [];
    
    groups.forEach(group => {
      const repColor = palette[group[0]];
      const mergedPaths = [];
      group.forEach(idx => {
        if (Array.isArray(layers[idx])) {
          mergedPaths.push(...layers[idx]);
        }
      });
      
      newPalette.push(repColor);
      newLayers.push(mergedPaths);
    });
    
    return { ...tracedata, palette: newPalette, layers: newLayers };
  }

  function createSolidSilhouette(tracedata, holeRemovalLevel) {
    if (!tracedata) return null;

    const visibleIndices = getVisiblePaletteIndices();
    if (!visibleIndices.length) return null;

    const subset = buildTracedataSubset(tracedata, visibleIndices);

    let mergedPaths = [];
    subset.layers.forEach(layer => { if (Array.isArray(layer)) mergedPaths = mergedPaths.concat(layer); });

    const w = tracedata.width || 512;
    const h = tracedata.height || 512;

    if (holeRemovalLevel > 0) {
      const f = (holeRemovalLevel / 10);
      const areaThreshold = w * h * (0.005 + 0.05 * f * f);
      const minGapPx = Math.max(1, Math.round(1 + 6 * f));
      mergedPaths = removeSmallHoles(mergedPaths, {
        areaThreshold,
        minGapPx,
        imageW: w,
        imageH: h
      });
    }

    return {
      width: subset.width,
      height: subset.height,
      layers: [mergedPaths],
      palette: [{ r: 0, g: 0, b: 0, a: 255 }]
    };
  }

  function removeSmallHoles(paths, opts = {}) {
    const { areaThreshold = 0, minGapPx = 1 } = opts;
    const maxSlenderness = 1800;

    const out = [];
    for (const p of paths) {
      if (p && p.isholepath) {
        const pts = getPathPoints(p);
        if (pts.length < 3) continue;
        const area = Math.abs(polygonArea(pts));
        const bbox = pathBBox(pts);
        const perim = approxPerimeter(pts);
        const slender = (perim * perim) / (area + 1);
        const minDim = Math.min(bbox.w, bbox.h);

        if (area < areaThreshold || minDim <= minGapPx || slender > maxSlenderness) {
          continue;
        }
      }
      out.push(p);
    }
    return out;
  }

  function getPathPoints(path) {
    const pts = [];
    if (!path || !Array.isArray(path.segments) || !path.segments.length) return pts;
    pts.push([path.segments[0].x1, path.segments[0].y1]);
    for (const seg of path.segments) pts.push([seg.x2, seg.y2]);
    return pts;
  }

  function polygonArea(pts) {
    let a = 0;
    for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
      const [xi, yi] = pts[i];
      const [xj, yj] = pts[j];
      a += (xj + xi) * (yj - yi);
    }
    return a / 2;
  }

  function pathBBox(pts) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const [x, y] of pts) {
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  function approxPerimeter(pts) {
    let p = 0;
    for (let i = 1; i < pts.length; i++) {
      p += Math.hypot(pts[i][0] - pts[i - 1][0], pts[i][1] - pts[i - 1][1]);
    }
    p += Math.hypot(pts[0][0] - pts[pts.length - 1][0], pts[0][1] - pts[pts.length - 1][1]);
    return p;
  }

  function selectBackgroundLayerOnly() {
    const container = elements.paletteContainer;
    if (!container) return;
    const cbs = container.querySelectorAll('input[type="checkbox"]');
    cbs.forEach(cb => { cb.checked = (cb.dataset.index === 'bg'); });
  }

  function enableDownloadButtons() {
    [elements.downloadTinkercadBtn, elements.downloadSilhouetteBtn].forEach(btn => {
      if (btn) btn.disabled = false;
    });
  }

  function disableDownloadButtons() {
    [elements.downloadTinkercadBtn, elements.downloadSilhouetteBtn].forEach(btn => {
      if (btn) btn.disabled = true;
    });
  }

  function renderColorButtons() {
    if (!elements.colorButtonsRow || !tracedata) {
      if (elements.colorButtonsRow) {
        elements.colorButtonsRow.style.display = 'none';
        elements.colorButtonsRow.innerHTML = '';
      }
      return;
    }
    
    const visibleIndices = getVisiblePaletteIndices();
    elements.colorButtonsRow.innerHTML = '';
    
    if (visibleIndices.length === 0) {
      elements.colorButtonsRow.style.display = 'none';
      return;
    }
    
    elements.colorButtonsRow.style.display = 'flex';
    
    visibleIndices.forEach((idx, ordinal) => {
      const color = tracedata.palette[idx];
      const button = document.createElement('button');
      
      button.innerHTML = `Layer ${ordinal + 1}<br>Download`;
      button.style.backgroundColor = `rgba(${color.r},${color.g},${color.b},${color.a/255})`;
      
      const luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
      button.style.color = luminance > 140 ? '#000' : '#fff';
      
      button.addEventListener('click', () => {
        const singleLayer = buildTracedataSubset(tracedata, [idx]);
        const hex = rgbToHex(color.r, color.g, color.b);
        const svgString = ImageTracer.getsvgstring(singleLayer, lastOptions);
        downloadSVG(svgString, `layer_${ordinal + 1}_${hex}`);
        elements.statusText.textContent = `📐 Layer ${ordinal + 1} downloaded for 3D printing!`;
      });
      
      elements.colorButtonsRow.appendChild(button);
    });
  }

  function rgbToHex(r, g, b) {
    return [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
  }

  function downloadSVG(svgContent, baseName) {
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${baseName || 'converted'}.svg`;
    document.body.appendChild(a);
a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  elements.importBtn?.addEventListener('click', () => {
    elements.fileInput?.click();
  });

  elements.fileInput?.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith('image/')) {
      alert('Please select a valid image file.');
      return;
    }

    elements.statusText.textContent = '📁 Loading your image...';
    const reader = new FileReader();
    
    reader.onload = (e) => {
      resetAutoGenerateFlag();
      elements.sourceImage.src = e.target.result;
      originalImageUrl = file.name;
    };
    
    reader.onerror = () => {
      elements.statusText.textContent = '❌ Error loading image file.';
    };
    
    reader.readAsDataURL(file);
  });

  elements.loadUrlBtn?.addEventListener('click', async () => {
    const url = elements.urlInput?.value?.trim();
    if (!url) {
      alert('Please enter an image URL.');
      return;
    }
    await loadImageFromUrl(url);
  });

  async function loadImageFromUrl(url) {
    elements.statusText.textContent = '🌐 Fetching image from URL...';
    originalImageUrl = url;
    
    try {
      if (url.startsWith('data:')) {
        elements.sourceImage.src = url;
        return;
      }

      if (typeof chrome !== 'undefined' && chrome.runtime?.connect) {
        const port = chrome.runtime.connect({ name: 'fetchImagePort' });
        
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            port.disconnect();
            reject(new Error('Timeout'));
          }, 10000);

          port.postMessage({ type: 'fetchImage', url });
          port.onMessage.addListener((response) => {
            clearTimeout(timeout);
            if (response.dataUrl) {
              resetAutoGenerateFlag();
              elements.sourceImage.src = response.dataUrl;
              resolve();
            } else {
              reject(new Error(response.error || 'Failed to fetch'));
            }
            port.disconnect();
          });
        });
      }

      let response;
      try {
        response = await fetch(url, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
      } catch (corsError) {
        const proxyUrl = 'https://images.weserv.nl/?url=' + encodeURIComponent(url);
        response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`Proxy failed: HTTP ${response.status}`);
      }

      const blob = await response.blob();
      const dataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      elements.sourceImage.src = dataUrl;
      resetAutoGenerateFlag();
      elements.statusText.textContent = '✅ Image loaded successfully!';

    } catch (error) {
      console.error('URL load error:', error);
      elements.statusText.textContent = '❌ Failed to load image from URL. Try downloading and importing locally.';
    }
  }

  elements.sourceImage.onload = () => {
    elements.sourceImage.style.display = 'block';
    elements.generateBtn.disabled = false;
    
    if (elements.originalResolution) {
      const w = elements.sourceImage.naturalWidth;
      const h = elements.sourceImage.naturalHeight;
      elements.originalResolution.textContent = `Original: ${w}×${h} pixels`;
    }

    if (elements.scaledResolution) {
      elements.scaledResolution.textContent = '';
    }

    if (elements.removeBgCheckbox) {
      const hasTransparency = detectTransparency(elements.sourceImage);
      elements.removeBgCheckbox.disabled = hasTransparency;
      elements.removeBgCheckbox.checked = !hasTransparency;
      
      if (hasTransparency) {
        elements.statusText.textContent = '🖼️ Image loaded! (Transparency detected - background removal disabled)';
      } else {
        elements.statusText.textContent = '🖼️ Image loaded! Auto-generating 3D-ready preview...';
      }
    }

    if (!autoGeneratedOnce) {
      autoGeneratedOnce = true;
      setTimeout(() => {
        elements.generateBtn.click();
      }, 100);
    }
  };

  function resetAutoGenerateFlag() {
    autoGeneratedOnce = false;
  }

  function detectTransparency(img) {
    const canvas = document.createElement('canvas');
    canvas.width = Math.min(img.naturalWidth, 100);
    canvas.height = Math.min(img.naturalHeight, 100);
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] < 250) return true;
    }
    return false;
  }

  function estimateEdgeBackground(imageData) {
    const { width, height, data } = imageData;
    let r = 0, g = 0, b = 0, count = 0;
    const step = Math.max(1, Math.floor(Math.min(width, height) / 50));
    
    const sample = (x, y) => {
      const i = (y * width + x) * 4;
      r += data[i]; g += data[i + 1]; b += data[i + 2]; count++;
    };
    
    for (let x = 0; x < width; x += step) {
      sample(x, 0); sample(x, height - 1);
    }
    for (let y = 0; y < height; y += step) {
      sample(0, y); sample(width - 1, y);
    }
    
    return { 
      r: Math.round(r / count), 
      g: Math.round(g / count), 
      b: Math.round(b / count), 
      a: 255 
    };
  }

  function knockOutBackground(imageData, bgColor, threshold = 30) {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const distance = Math.abs(data[i] - bgColor.r) + 
                       Math.abs(data[i + 1] - bgColor.g) + 
                       Math.abs(data[i + 2] - bgColor.b);
      if (distance <= threshold) {
        data[i + 3] = 0;
      }
    }
  }

  async function loadImageFromContextMenu() {
    if (typeof chrome === 'undefined' || !chrome.storage) return;
    
    try {
      elements.statusText.textContent = '🔍 Checking for context menu image...';
      const data = await chrome.storage.local.get('imageUrlToConvert');
      
      if (data.imageUrlToConvert) {
        await loadImageFromUrl(data.imageUrlToConvert);
        chrome.storage.local.remove('imageUrlToConvert');
      } else {
        elements.statusText.textContent = '🎯 Ready for 3D printing magic! Import an image to start.';
      }
    } catch (error) {
      console.log('Not in extension context or no stored image');
      elements.statusText.textContent = '🎯 Ready for 3D printing magic! Import an image to start.';
    }
  }

  function initializeApp() {
    loadImageFromContextMenu();
    console.log('🚀 3D Print SVG Converter initialized!');
  }

  initializeApp();
});
